{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/engineering-principles/","result":{"data":{"markdownRemark":{"id":"e0b6cca5-8d73-5d7e-84d0-34ace18dc3e9","excerpt":"To make it easier to understand my modus operandi, I’ve compiled a list of high-level technical principles and beliefs that I operate by. These principles are not meant to be exhaustive, and they…","html":"<p>To make it easier to understand my modus operandi, I’ve compiled a list of high-level technical principles and beliefs that I operate by. These principles are not meant to be exhaustive, and they definitely subject to change while I gain new perspectives and (hopefully) get wiser.</p>\n<p>I got inspired to write this post after reading the <a href=\"https://react.christmas/2019/24\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">principles of the React team</a>.</p>\n<h2>People first, technology second</h2>\n<p>Technology’s ultimate purpose is to advance humanity. If we do not put the human first in everything we do, then what is the point?</p>\n<p>We can easily get carried away solving problems and forgetting about the users – the why. I believe all technologist will benefit from understanding user-centered and human-centered design.</p>\n<p>Sidebar: Before studying computer science, I worked as an technical illustrator and later as a freelance web designer. I was always fascinated by human-computer interaction. Reading “Designing Web Usability” (1999) by Jakob Nielsen was a real eye opener. Later in life, working together with really skilled UX designers changed how I approach problems.</p>\n<p>Recommended material:</p>\n<ul>\n<li><a href=\"https://www.offscreenmag.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Offscreen</a> is my favorite print magazine on how we shape technology and how technology shapes us;</li>\n<li>Donald Norman’s classic best-selling book “The Design of Everyday Things” studies fundamental principles of great and meaningful design.</li>\n</ul>\n<h2>The only constant is change</h2>\n<p>The greek philosopher Heraclitus knew it ~2500 years ago: “Everything changes and nothing stands still”.</p>\n<blockquote>\n<p>Everything changes and nothing stands still.</p>\n<p>– Heraclitus (~500 BC)</p>\n</blockquote>\n<p>Code is organic, it evolves over time, and needs constant maintenance. As mentioned in <a href=\"https://www.artima.com/intv/garden.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><em>The Pragmatic Programmer</em></a>, software development resembles gardening, (although a common metaphor, software is nothing like construction engineering and architecture).</p>\n<p>To optimize a codebase for change I:</p>\n<ul>\n<li>keep things simple;</li>\n<li>prefer boring explicit code;</li>\n<li>invest in documentation, automation, and tests;</li>\n<li>encapsulate hard decision or decisions likely to change from other components in the system;</li>\n<li>prefer products over <a href=\"https://martinfowler.com/articles/products-over-projects.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">projects</a>;</li>\n<li>and <a href=\"https://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">write code that is easy to delete, not easy to extend</a>.</li>\n</ul>\n<h2>Always ask open questions</h2>\n<p>Incorporate asking open questions into your daily routine – both around the technologies used and the problem you are solving. Understand the technical details and ask:</p>\n<ul>\n<li>what problem are we trying to solve?</li>\n<li>is this even worth doing at all?</li>\n<li>is there are simpler way?</li>\n</ul>\n<p>If there are multiple solutions to a problem, then make pros and cons list and share them with your team members.</p>\n<h2>Fail fast and quickly validate hypothesis / Validate your hypothesis as quickly as possible</h2>\n<p>Requirements and your perspective will change as soon as you ship your product/software (or simply show it to users). So avoid gold-plating your design or code, and get your solution in front of real users as fast as possible. Rather fail fast than waste time.</p>\n<p>So: build quick prototypes, cut down on scope, and plan to throw code and designs away.</p>\n<blockquote>\n<p>In most projects, the first system built is barely usable… Hence plan to throw one away; you will, anyhow.</p>\n<p>– Fred Brooks, The Mythical Man-Month (1975)</p>\n</blockquote>\n<p>FIXME: reference to lean startup book.</p>\n<h2>Pick your battles</h2>\n<p>Gandalf was right. Time is our most scarce resource, and we should prioritize wisely. It means picking <em>meaningful</em> battles that we have a chance winning.</p>\n<p>A lot of time can easily be wasted on nitpicking, while important issues are completely ignored. I love the <a href=\"http://phk.freebsd.dk/sagas/bikeshed/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">bike-shed analogy</a> by Poul-Henning Kamp as a classic example of Parkinson’s law of triviality.</p>\n<h2>Prefer duplication over the wrong abstraction</h2>\n<p>“Don’t Repeat Yourself” is often misunderstood. Although programming is about avoiding work, prematurely sharing code can be really expensive. Although the code and functionality looks the same, the requirements or direction might differ.</p>\n<p>Recommended material:</p>\n<ul>\n<li>Sandi Metz <a href=\"https://www.sandimetz.com/blog/2016/1/20/the-wrong-abstraction\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">“The Wrong Abstraction”</a>.</li>\n<li>Joe Spolsky <a href=\"https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">“The Law of Leaky Abstractions”</a>. “All non-trivial abstractions, to some degree, are leaky”.</li>\n</ul>\n<h2>Invest in safety nets</h2>\n<p>“We don’t have time to write tests” means we spend too much time bug fixing because we don’t have enough safety nets. Have enough safety nets to not be afraid to deploy to production when merging your main branch.</p>\n<h2>Cross functional teams all the way</h2>\n<p>Splitting teams based on competences, or where in the stack their code runs, is easy, but counter-productive and sub-optimal. It introduces an overhead in terms of communication and requirements specifications. The most effective teams I’ve ever worked in, where all diverse cross functional (design, UX, frontend, backend, product, domain experts).</p>\n<h2>Pragmatism</h2>\n<h2>Continuos deployment/integration</h2>\n<h2>Contribute to Open Source Software</h2>\n<hr>\n<h2>What are your engineering principles?</h2>\n<p>These are some of the high-level engineering principles I operate by when building software.</p>\n<p>Do you, or your team have a set of principles? I would love to hear about them.</p>","frontmatter":{"title":"My Software Engineering Principles","date":"January 08, 2020","description":"To make it easier to understand my modus operandi, I've compiled a list of high-level technical principles and beliefs that I operate by.","featuredImage":null}},"site":{"siteMetadata":{"siteUrl":"https://skovhus.github.io"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/engineering-principles/","previous":{"fields":{"slug":"/my-way-into-programming/"},"frontmatter":{"title":"How I got into programming DRAFT"}},"next":null}}}